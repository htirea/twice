#include "nds/cart/dldi.h"

#include "nds/nds.h"

namespace twice {

static const u8 driver[512] = {
	0xed, 0xa5, 0x8d, 0xbf, 0x20, 0x43, 0x68, 0x69, //
	0x73, 0x68, 0x6d, 0x00, 0x01, 0x09, 0x00, 0x09, //
	0x54, 0x77, 0x69, 0x63, 0x65, 0x20, 0x44, 0x4c, //
	0x44, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //
	0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, //
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //
	0x54, 0x57, 0x43, 0x45, 0x23, 0x00, 0x00, 0x00, //
	0x80, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, //
	0xc0, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, //
	0x3c, 0x01, 0x00, 0x00, 0x5c, 0x01, 0x00, 0x00, //
	0x01, 0x20, 0xa0, 0xe3, 0x10, 0x30, 0x9f, 0xe5, //
	0xf0, 0x2e, 0x83, 0xe5, 0xf0, 0x0e, 0x93, 0xe5, //
	0x01, 0x00, 0x70, 0xe2, 0x00, 0x00, 0xa0, 0x33, //
	0x1e, 0xff, 0x2f, 0xe1, 0x00, 0x00, 0xef, 0x04, //
	0x02, 0x20, 0xa0, 0xe3, 0x10, 0x30, 0x9f, 0xe5, //
	0xf0, 0x2e, 0x83, 0xe5, 0xf0, 0x0e, 0x93, 0xe5, //
	0x01, 0x00, 0x70, 0xe2, 0x00, 0x00, 0xa0, 0x33, //
	0x1e, 0xff, 0x2f, 0xe1, 0x00, 0x00, 0xef, 0x04, //
	0x03, 0xc0, 0xa0, 0xe3, 0x2c, 0x30, 0x9f, 0xe5, //
	0xf0, 0xce, 0x83, 0xe5, 0xf0, 0x0e, 0x83, 0xe5, //
	0xf0, 0x1e, 0x83, 0xe5, 0x81, 0x14, 0x82, 0xe0, //
	0x01, 0x00, 0x52, 0xe1, 0xf0, 0x0e, 0x93, 0xe5, //
	0x02, 0x00, 0x00, 0x1a, 0x01, 0x00, 0x70, 0xe2, //
	0x00, 0x00, 0xa0, 0x33, 0x1e, 0xff, 0x2f, 0xe1, //
	0x01, 0x00, 0xc2, 0xe4, 0xf7, 0xff, 0xff, 0xea, //
	0x00, 0x00, 0xef, 0x04, 0x04, 0xc0, 0xa0, 0xe3, //
	0x30, 0x30, 0x9f, 0xe5, 0xf0, 0xce, 0x83, 0xe5, //
	0xf0, 0x0e, 0x83, 0xe5, 0xf0, 0x1e, 0x83, 0xe5, //
	0x81, 0x14, 0x82, 0xe0, 0x01, 0x00, 0x52, 0xe1, //
	0x03, 0x00, 0x00, 0x1a, 0xf0, 0x0e, 0x93, 0xe5, //
	0x01, 0x00, 0x70, 0xe2, 0x00, 0x00, 0xa0, 0x33, //
	0x1e, 0xff, 0x2f, 0xe1, 0x01, 0x00, 0xd2, 0xe4, //
	0xf0, 0x0e, 0x83, 0xe5, 0xf6, 0xff, 0xff, 0xea, //
	0x00, 0x00, 0xef, 0x04, 0x05, 0x20, 0xa0, 0xe3, //
	0x10, 0x30, 0x9f, 0xe5, 0xf0, 0x2e, 0x83, 0xe5, //
	0xf0, 0x0e, 0x93, 0xe5, 0x01, 0x00, 0x70, 0xe2, //
	0x00, 0x00, 0xa0, 0x33, 0x1e, 0xff, 0x2f, 0xe1, //
	0x00, 0x00, 0xef, 0x04, 0x06, 0x20, 0xa0, 0xe3, //
	0x10, 0x30, 0x9f, 0xe5, 0xf0, 0x2e, 0x83, 0xe5, //
	0xf0, 0x0e, 0x93, 0xe5, 0x01, 0x00, 0x70, 0xe2, //
	0x00, 0x00, 0xa0, 0x33, 0x1e, 0xff, 0x2f, 0xe1, //
	0x00, 0x00, 0xef, 0x04                          //
};

void
dldi_init(nds_ctx *nds)
{
	auto& dldi = nds->dldi;
	dldi.data = nds->image_v.data();
	dldi.size = nds->image_v.size();

	if (dldi.data) {
		dldi_patch_cart(nds);
	} else {
		LOG("no image file loaded: not patching\n");
	}
}

void
dldi_patch_cart(nds_ctx *nds)
{
	auto& cart = nds->cart;

	u8 *header = std::search(
			cart.data, cart.data + cart.size, driver, driver + 12);
	if (header == cart.data + cart.size) {
		return;
	}

	if (cart.data + cart.size - header < (ptrdiff_t)(sizeof driver)) {
		LOG("not enough space for dldi driver: not patching\n");
		return;
	}

	u32 base_addr = readarr<u32>(header, 0x40);
	std::copy(driver, driver + sizeof driver, header);

	writearr<u32>(header, 0x40, base_addr);
	for (u32 offset = 0x68; offset < 0x80; offset += 4) {
		u32 addr = readarr<u32>(driver, offset);
		writearr<u32>(header, offset, base_addr + addr);
	}

	LOG("patched dldi at cart offset: %08lX, memory offset: %08X\n",
			header - cart.data, base_addr);
}

u32
dldi_reg_read(nds_ctx *nds)
{
	auto& dldi = nds->dldi;

	switch (dldi.cmd) {
	case 1:
	case 2:
	case 5:
	case 6:
		dldi.cmd = 0;
		return dldi.value_r;
	case 3:
		if (dldi.bytes_left == 0) {
			dldi.cmd = 0;
			return dldi.error;
		}

		if (!dldi.data || dldi.shutdown || dldi.addr >= dldi.size) {
			dldi.error = true;
			return 0;
		}

		dldi.bytes_left--;
		return readarr<u8>(dldi.data, dldi.addr++);
		break;
	case 4:
		dldi.cmd = 0;
		dldi.write_q.write_in_progress = false;
		file_queue_add(&dldi.write_q, dldi.data, dldi.size,
				dldi.write_start_addr, dldi.addr);
		return dldi.error;
	}

	return 0;
}

void
dldi_reg_write(nds_ctx *nds, u32 value)
{
	auto& dldi = nds->dldi;

	if (dldi.cmd == 0) {
		dldi.cmd = value;
		dldi.count = 0;
	}

	switch (dldi.cmd) {
	case 1: /* startup */
		dldi.shutdown = dldi.data ? false : true;
		dldi.value_r = dldi.data ? 0 : 1;
		break;
	case 2: /* is_inserted */
		dldi.value_r = dldi.data && !dldi.shutdown ? 0 : 1;
		break;
	case 3: /* read_sectors */
		switch (dldi.count) {
		case 0:
			break;
		case 1:
			dldi.addr = value * 512;
			break;
		case 2:
			dldi.bytes_left = value * 512;
			break;
		}
		dldi.count++;
		break;
	case 4: /* write_sectors */
		switch (dldi.count) {
		case 0:
			break;
		case 1:
			dldi.addr = value * 512;
			dldi.write_start_addr = dldi.addr;
			break;
		case 2:
			dldi.bytes_left = value * 512;
			dldi.write_q.write_in_progress = true;
			break;
		default:
			if (!dldi.data || dldi.shutdown ||
					dldi.addr >= dldi.size) {
				dldi.error = true;
			} else {
				writearr<u8>(dldi.data, dldi.addr++, value);
			}
			break;
		}
		dldi.count++;
		break;
	case 5: /* clear_status */
		dldi.error = false;
		dldi.value_r = dldi.data ? 0 : 1;
		break;
	case 6: /* shutdown */
		dldi.shutdown = true;
		dldi.value_r = 0;
	}
}

void
sync_image_file(nds_ctx *nds, bool sync_whole_file)
{
	if (!nds->image)
		return;

	auto& dldi = nds->dldi;
	if (sync_whole_file) {
		file_queue_add(&dldi.write_q, dldi.data, dldi.size, 0,
				dldi.size);
	}

	file_queue_flush(&dldi.write_q, nds->image, dldi.data);
}

} // namespace twice
